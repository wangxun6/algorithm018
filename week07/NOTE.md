学习笔记
这周主要对字典树（Trie树），并查集，高级搜索，红黑树和AVL树。
首先对于字典树：
	字典树又称为单词搜索树，主要应用在统计、排序大量字符串（但又不仅限于字符串）。主要应用于搜素引擎中文本词频统计，利用字符串的前缀来减少查询时间，最大限度地减少五位的字符串比较，查询效率比哈希树高。
字典树的主要性质为：
根节点不包含字符，除根节点外每一个节点都只包含一个字符；
从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串；
每个节点的所有子节点包含的字符都不相同。
其要求是能够实现一个Trie树
其次并查集：
并查集（Union-find）数据结构也称作合并查找集（Merge-find set）或者不相交集数据结构（disjoint-set data structure），它是一种记录了由一个或多个元素组成的不连续的分组的集合。并查集提供常数量的复杂度来添加、合并以及确定两个元素是否属于同一个集合。
并查集是一种树形数据结构，但是它和二叉树、红黑树、B树不同，它对树形结构的要求十分简单：
同一个数据组中的元素对应在同一颗树（判断两个元素是否在同一颗树时，可以判断根结点是否相同）
同一数据组中的每一个元素对应树中的一个结点
不同数据组之间不存在任何相关的联系，可以看做多个数据组成一个森林（合并数据组时，只需要将一棵树的根结点指向另一颗树的根结点即可）
树中的结点不存在硬性的顺序/父子关系
高级搜索：
启发式搜索：启发式是一个经验法则，它引导我们找到可能的解决方案。
其代码模板为：
def AstarSearch(graph, start, end):
pq = collections.priority_queue() # 优先级 —> 估价函数
pq.append([start]) 
visited.add(start)
while pq: 
node = pq.pop() # can we add more intelligence here ?
visited.add(node)
process(node) 
nodes = generate_related_nodes(node) 
   unvisited = [node for node in nodes if node not in visited]
pq.push(unvisited)
此外还有剪枝，双向BFS算法
最后是AVL树和红黑树
红黑树和AVL树都是平衡二叉查找树
红黑树（RBTree）：是一种非严格平衡的二叉查找树，即不完全符合左右子树的高度差最大为1这个条件，通过引入节点颜色来降低旋转次数
AVL树：是一种严格平衡的二叉查找树，即严格遵循左右子树的高度差最大为1这个条件。
在插入和删除节点方面，RBTree要比AVL树的插入和删除效率要高很多。

